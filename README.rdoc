  _    _     _   ___      _
 |*|_|*|___|*|_|*  |___ |*|_ ___ ___ ___
 | | | |*_ |   | | |* _|   _|*  |* _|*__|
 | | | | __| | |   | |_ | |_| | | | |__ |
 |_____|___|___|_|_|___||___|___|_| |___|

WebActors is a simple library for managing concurrency
in JavaScript programs. It's based on Erlang's
adaptation of the Actor Model.

For an introduction to actors in general, and WebActors in
particular, scroll down to the section entitled
"Tutorial".

= Building

== Build Requirements

WebActors doesn't have any special run-time requirements
-- it's just a single JavaScript file -- but for now it
does require ruby, rake, the coffee_script gem and the YUI
compressor to build from source code.

A suitable version of YUI Compressor is availabile from
Ubuntu Universe as the <code>yui-compressor</code>
package.

(Eventually I'd like to move to a pure-JavaScript build
system.)

== Running Rake

Running <code>rake</code> with no arguments will build
everything.

The output files are:

 - dist/webactors.js - uncompressed version
 - dist/webactors.min.js - minfied version

The two should be functionally-equivalent.

= API Reference

WebActors defines a single object in the top-level
namespace, unsurprisingly called WebActors.  It has a
number of properties and methods attached to it.

== Actors

=== WebActors.spawn(body) -> actor_id

The <code>spawn</code> method spawns a new actor, returning
its id.

The actor will termiate after <code>body</code> returns,
unless <code>body</code> suspends the actor by calling
<code>receive</code>.

=== WebActors.spawn_linked(body) -> actor_id

The <code>spawn_linked</code> method is similar to
<code>spawn</code>, except that it atomically links the
spawned actor with the current actor.

=== WebActors.self()

The <code>self</code> method returns the id of the current
actor.

=== WebActors.send(actor_id, message)

Sends a message to another actor asynchronously. The
message is put in the receiving actor's mailbox, to
be retrieved with <code>receive</code>.

=== WebActors.send_self(message)

Like <code>send</code>, but sends a message to the current
actor's mailbox.

=== WebActors.receive(pattern, cont)

Sets up a one-shot handler to be called if a message
matching the given pattern arrives.  The pattern will
be structurally matched against candidate messages
using <code>match</code>; a list of captured subvalues will
be passed to the supplied continuation callback.

The set of outstanding receives for an actor is
cleared each time the actor successfully receives
a message.

If an actor doesn't establish any receives before
returning to the event loop, or if it raises an
uncaught exception, the actor will terminate.

=== WebActors.link(actor_id)

The <code>link</code> method links the current actor with
the given actor, provided there wasn't already an existing
link between them.

<code>link</code> will raise an error if the named actor is
dead or doesn't exist.

=== WebActors.unlink(actor_id)

The <code>unlink</code> method unlinks the current actor
from the given actor, if there was an existing link between
the two.

<code>unlink</code> _won't_ raise an error if no actor with
the given id exists.

=== WebActors.kill(recipient_id, reason)

The <code>kill</code> method sends a kill to the given actor
whether or not it is linked with the current actor.

=== WebActors.trap_kill(fn)

Normally, when an actor receives a kill, it will immediately
exit.  <code>trap_kill</code> allows for more nuanced behavior
than the default, converting the kill into a regular message.

This passed-in function receives two arguments: the id of
the originating (not the receiving!) actor, and the reason
for the kill.  It should return a message to be delivered to
the receiving actor.

=== WebActors.sendback(args...) -> cb

Constructs a callback that sends a message to the actor
that constructed it.  Useful for waiting with setTimeout.

The message sent will consist of the arguments to
<code>sendback</code> concatented with any arguments passed
to the callback when it is called.

== Pattern Matching

=== WebActors.match(pattern, value) -> result

<code>match</code> performs structural matching on JavaScript values.
It takes a pattern and a value, returning an array of
captured subvalues if the match is successful, or null
otherwise.

=== WebActors.any or WebActors.$_

<code>$_</code> matches any value without capturing it.

=== WebActors.capture or WebActors.$$

<code>$$</code> matches and captures any value; the match
may be further constrained by passing an argument to
<code>$$</code> as a function.

= Tutorial

== Actors Explained

An "actor" is pretty much just a regular process or
thread with a mailbox attached.  In programming styles
based on the Actor Model, threads communicate with each
other by posting immutable messages to each others'
mailboxes, rather than by reading and writing fields of
mutually-shared objects.

Writing concurrent programs using message-passing can take
some getting used to, but actors can make programs simpler,
and they are also relatively safe from many common
programming errors.

== Actors in JavaScript

JavaScript has neither processes nor threads (nor
coroutines), but in the absence of these, actors can still
be modeled by a chain of callbacks.  Indeed, actor-based
programming can be a good way to manage the inherent
complexities of callback-driven programming.

=== Creating Actors and Sending Messages

The <code>WebActors.spawn</code> function is used to
create a new actor.  This function takes a callback to run
in the new actor's context, and returns an id representing
the newly created actor.  This id can be used to submit
messages to the new actor's mailbox.

 var actor = WebActors.spawn(a_callback); // create an actor
 WebActors.send(actor, "a message"); // send it a message

=== Receiving Messages

To receive messages, use the <code>WebActors.receive</code>
function.  It takes a pattern and a callback to be invoked
when a matching message is received.

 function a_callback() {
   // $$ matches anything
   WebActors.receive(WebActors.$$, function (message) {
     alert(message);
   });
 }

If an actor callback sets up a new callback via receive,
then the actor will continue with the new callback once
a matching message becomes available.  Otherwise, if a
callback "breaks the chain", then the actor will terminate
as soon as the callback finishes.

In the above example, the actor sets up a callback to
receive one message. That callback, in turn, doesn't set
up any further callbacks, so the actor terminates at
that point.

=== Saving Some Typing

If you aren't already in the habit of doing so, it can
be useful (and occasionally more readable) to define local
aliases for functions defined on library objects.

 (function () {
 var spawn = WebActors.spawn;
 var receive = WebActors.receive;
 var send = WebActors.send;
 var $$ = WebActors.$$;

 function a_callback() {
   // $$ matches anything
   WebActors.receive($$, function (message) {
     alert(message);
   });
 }

 actor = spawn(a_callback); // create an actor
 send(actor, "a message"); // send it a message
 
 })();

Subsequent code samples will assume that such aliases have
already been defined.

=== Multiple Receives

An actor can also choose between alternatives based on
the specific message received. (This is a fragment,
rather than a complete example.)

 receive("go left", function () {
   alert("You fall off a cliff.");
 });
 receive("go right", function () {
   alert("You stumble into a pit full of spikes.");
 });

In this case, if the actor receives "go left", it will
print the message about falling off a cliff.  If it
receives "go right", it will print the message about
falling into a pit.

In both cases the actor terminates after printing its
message, since neither callback sets up any new receives.
